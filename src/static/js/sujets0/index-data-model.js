/**
 * Data Model Module for Sujets0
 * Provides structured classes for managing generator output data
 */

/**
 * Class representing a component used in question generation
 */
export class Component {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }

    /**
     * Get the LaTeX representation if available
     * @returns {string|null} LaTeX representation or null
     */
    getLatex() {
        return typeof this.value === 'string' ? this.value : null;
    }
}

/**
 * Class representing a mathematical answer
 */
export class Answer {
    constructor(data = {}) {
        // latex can now be an array or a single value
        this.latex = data.latex || null;
        this.simplified_latex = data.simplified_latex || null;
        this.sympy_exp_data = data.sympy_exp_data || null;
        this.formal_repr = data.formal_repr || null;
    }

    /**
     * Get all LaTeX representations as an array
     * @returns {Array} Array of LaTeX strings
     */
    getAllLatex() {
        if (Array.isArray(this.latex)) {
            return this.latex;
        } else if (this.latex) {
            return [this.latex];
        }
        return [];
    }

    /**
     * Get the best available LaTeX representation
     * @returns {string} The first LaTeX from array, simplified LaTeX, or regular LaTeX
     */
    getBestLatex() {
        if (Array.isArray(this.latex) && this.latex.length > 0) {
            return this.latex[0];
        }
        return this.simplified_latex || this.latex || '';
    }
}

/**
 * Class representing a question generated by a Python generator
 */
export class Question {
    constructor(data = {}) {
        this.generator = data.generator || null;
        this.success = data.success || false;
        this.error = data.error || null;
        this.statement = data.statement || null;
        this.data = data.data || null;
        this.answer = data.answer || null;
        this.graphSvg = data.graphSvg || null;
        this.graphDict = data.graphDict || null;
    }

    /**
     * Create a Question from raw data returned by executeGeneratorWithSeed
     * @param {Object} rawData - Raw data from generator execution
     * @param {string} generatorName - Name of the generator
     * @returns {Question} A structured Question object
     */
    static fromGeneratorResult(rawData, generatorName) {
        // Base question properties
        const question = new Question({
            generator: generatorName.replace('.py', ''),
            success: rawData.success,
            error: rawData.error,
            statement: rawData.statement,
            data: rawData.data,
            graphSvg: rawData.graphSvg,
            graphDict: rawData.graphDict
        });

        // Process answer if successful
        if (rawData.success && rawData.answer) {
            if (typeof rawData.answer === 'object') {
                question.answer = new Answer(rawData.answer);
            } else {
                question.answer = new Answer({
                    latex: rawData.answer,
                    simplified_latex: rawData.answer
                });
            }
        }

        // Process components if available
        if (rawData.data?.components) {
            question.components = Object.entries(rawData.data.components).map(
                ([key, value]) => new Component(key, value)
            );
        }

        return question;
    }

    /**
     * Get the beacon identifier
     * @returns {string|null} The beacon identifier or null
     */
    getBeacon() {
        return this.data?.beacon || null;
    }

    /**
     * Get the statement HTML content
     * @returns {string|null} HTML content or null
     */
    getStatementHtml() {
        return this.data?.statement_html || null;
    }

    /**
     * Get the mask for the answer (e.g., "F=")
     * @returns {string|null} The mask or null
     */
    getMask() {
        return this.data?.mask || null;
    }

    /**
     * Get all possible answer representations
     * @returns {Array} Array of all possible answers
     */
    getAllAnswers() {
        if (!this.success || !this.answer) return [];
        
        if (typeof this.answer === 'string') {
            return [this.answer];
        }
        
        if (this.answer instanceof Answer) {
            const allLatex = this.answer.getAllLatex();
            // Debug logging for multi-answer support
            if (allLatex.length > 1) {
                console.log(`Question ${this.generator} has ${allLatex.length} answers:`, allLatex);
            }
            return allLatex;
        }
        
        // Handle legacy format
        if (Array.isArray(this.answer?.latex)) {
            return this.answer.latex;
        } else if (this.answer?.latex) {
            return [this.answer.latex];
        }
        
        return [];
    }

    /**
     * Get the best answer representation
     * @returns {string} The best available answer
     */
    getBestAnswer() {
        const allAnswers = this.getAllAnswers();
        return allAnswers.length > 0 ? allAnswers[0] : '';
    }
}

/**
 * Class representing a student's generated exercise set
 */
export class StudentExerciseSet {
    /**
     * Create a new StudentExerciseSet
     * @param {Object} data - The data for this student
     * @param {number} data.id - Student identifier
     * @param {number} data.seed - Seed used for generation
     * @param {Array} data.questions - Questions for this student
     */
    constructor(data = {}) {
        this.id = data.id || 0;
        this.seed = data.seed || 0;
        this.questions = data.questions?.map(q => 
            q instanceof Question ? q : new Question(q)
        ) || [];
    }

    /**
     * Create a student exercise set from raw data
     * @param {number} studentId - The student identifier
     * @param {number} seed - The seed used for generation
     * @param {Array} questionResults - Array of raw generator results
     * @param {Array} generatorNames - Array of generator names
     * @returns {StudentExerciseSet} The structured student exercise set
     */
    static fromGeneratorResults(studentId, seed, questionResults, generatorNames) {
        const questions = questionResults.map((result, index) => 
            Question.fromGeneratorResult(result, generatorNames[index])
        );
        
        return new StudentExerciseSet({
            id: studentId,
            seed: seed,
            questions: questions
        });
    }

    /**
     * Get the count of successful questions
     * @returns {number} Number of successful questions
     */
    getSuccessCount() {
        return this.questions.filter(q => q.success).length;
    }

    /**
     * Get the total question count
     * @returns {number} Total number of questions
     */
    getTotalCount() {
        return this.questions.length;
    }
}

/**
 * Class representing the full generation results
 */
export class GenerationResults {
    constructor() {
        this.students = [];
        this.selectedGenerators = [];
        this.currentStudentIndex = 0;
        this.config = null;
    }

    /**
     * Add a student exercise set
     * @param {StudentExerciseSet} student - The student exercise set to add
     */
    addStudent(student) {
        if (student instanceof StudentExerciseSet) {
            this.students.push(student);
        } else {
            this.students.push(new StudentExerciseSet(student));
        }
    }

    /**
     * Get the current student
     * @returns {StudentExerciseSet|null} The current student or null
     */
    getCurrentStudent() {
        if (this.students.length === 0) return null;
        return this.students[this.currentStudentIndex];
    }

    /**
     * Set the configuration
     * @param {Object} config - Configuration object
     */
    setConfig(config) {
        this.config = config;
    }

    /**
     * Set the selected generators
     * @param {Array} generators - Array of generator names
     */
    setSelectedGenerators(generators) {
        this.selectedGenerators = generators;
    }

    /**
     * Navigate to a specific student
     * @param {number} index - Student index to navigate to
     * @returns {boolean} Whether navigation was successful
     */
    navigateTo(index) {
        if (index >= 0 && index < this.students.length) {
            this.currentStudentIndex = index;
            return true;
        }
        return false;
    }

    /**
     * Reset all data
     */
    reset() {
        this.students = [];
        this.currentStudentIndex = 0;
    }
}

// Default export of a singleton instance
export default new GenerationResults();
